/* minimal_mcp2518_spi.c
   Build in CCS (MSPM0 SDK). Beginner-friendly blocking SPI + manual CS example.
*/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#include <ti/drivers/SPI.h>
#include <ti/drivers/GPIO.h>
#include "Board.h"   // generated by SysConfig or your board example

/* MCP2518 commands */
#define MCP_CMD_RESET    0x0
#define MCP_CMD_WRITE    0x2
#define MCP_CMD_READ     0x3

static SPI_Handle spiHandle;

/* Initialize SPI and CS GPIO */
void mcp_spi_init(void)
{
    SPI_Params spiParams;
    SPI_init();
    SPI_Params_init(&spiParams);

    spiParams.frameFormat = SPI_POL1_PHA1;   // mode 1,1 (matches datasheet options)
    spiParams.dataSize = 8;                  // 8-bit frames
    spiParams.bitRate = 1000000;             // 1 MHz to start (safe); you can increase up to 20MHz carefully
    spiParams.transferMode = SPI_MODE_BLOCKING;

    /* Open SPI instance - replace Board_SPI0 with your board's SPI ID */
    spiHandle = SPI_open(Board_SPI0, &spiParams);
    if (!spiHandle) {
        // handle error: SPI_open failed
        while(1);
    }

    /* Configure CS pin (manual) - ensure it's high when idle */
    GPIO_setConfig(Board_GPIO_MCP2518_CS, GPIO_CFG_OUT_STD | GPIO_CFG_OUT_STR_LOW | GPIO_CFG_OUT_HIGH);
    GPIO_write(Board_GPIO_MCP2518_CS, 1); // CS high idle

    /* Configure INT pin as input with falling-edge callback if you want interrupts */
    GPIO_setConfig(Board_GPIO_MCP2518_INT, GPIO_CFG_IN_NOPULL);
}

/* helper: assert/deassert CS */
static inline void mcp_cs_assert(void)  { GPIO_write(Board_GPIO_MCP2518_CS, 0); }
static inline void mcp_cs_deassert(void){ GPIO_write(Board_GPIO_MCP2518_CS, 1); }

/* Perform a single SPI transfer while holding CS low for the whole instruction */
static bool mcp_spi_transfer(const uint8_t *txBuf, uint8_t *rxBuf, size_t len)
{
    SPI_Transaction trans;
    memset(&trans, 0, sizeof(trans));
    trans.count = len;
    trans.txBuf = (void*)txBuf;
    trans.rxBuf = rxBuf;

    bool ok = SPI_transfer(spiHandle, &trans);
    return ok;
}

/* Build command header (2 bytes): C[3:0], A[11:0] */
static void build_header(uint8_t header[2], uint8_t cmd, uint16_t addr)
{
    header[0] = (uint8_t)((cmd << 4) | ((addr >> 8) & 0x0F));
    header[1] = (uint8_t)(addr & 0xFF);
}

/* Read N bytes from MCP2518 starting at addr */
bool mcp_read(uint16_t addr, uint8_t *out, size_t n)
{
    uint8_t header[2];
    build_header(header, MCP_CMD_READ, addr);

    size_t tot = 2 + n;
    uint8_t tx[64]; // adjust if n may be larger
    uint8_t rx[64];
    if (tot > sizeof(tx)) return false;

    tx[0] = header[0];
    tx[1] = header[1];
    for (size_t i=0;i<n;i++) tx[2+i] = 0x00; // dummy bytes to clock out data

    mcp_cs_assert();
    bool ok = mcp_spi_transfer(tx, rx, tot);
    mcp_cs_deassert();

    if (!ok) return false;

    // rx[0..1] are the bytes during header (usually don't contain data), rx[2..] are returned data
    memcpy(out, &rx[2], n);
    return true;
}

/* Write N bytes to MCP2518 starting at addr */
bool mcp_write(uint16_t addr, const uint8_t *data, size_t n)
{
    uint8_t header[2];
    build_header(header, MCP_CMD_WRITE, addr);

    size_t tot = 2 + n;
    uint8_t tx[64];
    uint8_t rx[64];
    if (tot > sizeof(tx)) return false;

    tx[0] = header[0];
    tx[1] = header[1];
    memcpy(&tx[2], data, n);

    mcp_cs_assert();
    bool ok = mcp_spi_transfer(tx, rx, tot);
    mcp_cs_deassert();

    return ok;
}

/* Send a RESET instruction (no data) */
bool mcp_reset(void)
{
    uint8_t header[2];
    build_header(header, MCP_CMD_RESET, 0x000);

    uint8_t rx[2];
    mcp_cs_assert();
    bool ok = mcp_spi_transfer(header, rx, 2);
    mcp_cs_deassert();
    return ok;
}

/* Example: sanity read of address 0x000 (C1CON LSB) */
void example_check(void)
{
    uint8_t buf[4];
    if (mcp_read(0x000, buf, 1)) {
        // buf[0] contains C1CON LSB
    } else {
        // read failed
    }
}

int main(void)
{
    // Board_init(); // if using board init from SysConfig
    mcp_spi_init();
    mcp_reset();
    // small delay to let device reset and enter config mode (use a timer or simple loop)
    for (volatile int i=0;i<100000;i++);

    // read a register to verify comms
    uint8_t r;
    if (mcp_read(0x000, &r, 1)) {
        // success: device responded
    }

    while (1) {
        // your main loop: handle interrupts, call mcp_read/mcp_write to configure CAN
    }
}
